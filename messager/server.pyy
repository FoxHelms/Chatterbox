from socket import socket as s
from socket import AF_INET, SOCK_STREAM
import logging
from concurrent.futures import ThreadPoolExecutor

class ChatServer:
	def __init__(self, host, port):
		self.logger = self._setup_logger()
		self.sock = self._setup_socket(host, port)
		self.connections = []
		self.executor = ThreadPoolExecutor()
	
	def run(self):
		self.logger.info("Chat server is running")
		while True:
			conn, addr = self.sock.accept()
			self.logger.debug(f"New connection: {addr}")
			new_connection_alert = f"{addr} just joined the chat!"
			connected_addresses = []
			for existing_conn in self.connections:
				existing_conn.send(new_connection_alert.encode())
				connected_addresses.append(existing_conn.getsockname())			
			
			index_addr = enumerate(connected_addresses)
			address_list_string = ''
			for i_a in index_addr:
				address_list_string += f"{i_a[0]} :  {i_a[1]}\n"
			welcome_message = f"Who would you like to chat with?\n {address_list_string}"
			if len(self.connections) == 0:
				welcome_message = "You're the only person online. Wait for someone to join"
			conn.send(welcome_message.encode())
			self.connections.append(conn)
			self.logger.debug(f"Connections: {self.connections}")
			
			self.executor.submit(self.relay_messages, conn, addr)
	
	def relay_messages(self, conn, addr):
		while True:
			data = conn.recv(1024)
			self.logger.debug(f'{addr[0]} said {data.decode()}')

			for connection in self.connections:
				
				connection.send(data)
				self.logger.debug('data sent!')

			if not data:
				self.logger.warning("No data. Exiting")
				break		

	@staticmethod
	def _setup_socket(host, port):	
		sock = s(AF_INET, SOCK_STREAM)
		sock.bind((host, port))
		sock.listen()
		return sock
		
	@staticmethod
	def _setup_logger():
		logger = logging.getLogger('chat_server')
		logger.addHandler(logging.StreamHandler())
		logger.setLevel(logging.DEBUG)
		return logger

if __name__ == "__main__":
	server = ChatServer('localhost', 8080)
	server.run()
